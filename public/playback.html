<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf--8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>CCTV Playback</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css" rel="stylesheet">
    <style>
      :root {
        --bg1: #f8fafc;
        --bg2: #e2e8f0;
        --ink: #1e293b;
        --muted: #64748b;
        --slate-900: #0f172a;
        --slate-800: #1e293b;
        --brand-500: #2563eb;
        --brand-600: #1d4ed8;
        --brand-soft: #e0f2fe;
        --danger: #ef4444;
        --radius: 1.25rem;
        --radius-sm: .75rem;
        --radius-pill: 999px;
        --shadow: 0 8px 24px rgba(0,0,0,.08);
      }
      body {
        background: linear-gradient(135deg, var(--bg1), var(--bg2));
        color: var(--ink);
        font-family: 'Poppins', system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji', sans-serif;
        transition: background 0.3s, color 0.3s;
      }
      .card { border-radius: var(--radius); border:none; background:#fff; box-shadow: var(--shadow); transition: background-color 0.3s; }
      .ratio { border-radius: 1rem; overflow:hidden; background: var(--slate-900); }
      .loader { display:inline-block; width:18px; height:18px; border:2px solid rgba(0,0,0,.1); border-top-color: rgba(0,0,0,.8); border-radius:50%; animation: spin 1s linear infinite; }
      @keyframes spin { to { transform: rotate(360deg); } }
      .controls { gap:.5rem; }
      .controls button { border-radius: var(--radius-pill); padding: .45rem .9rem; display: flex; align-items: center; gap: 6px; font-weight: 500; }
      .controls select, .controls input, .controls .btn { font-size: .875rem; }
      .controls .btn-primary { background: linear-gradient(90deg, var(--brand-500), var(--brand-600)); border: none; }
      .controls .btn-outline-primary:hover { background: var(--brand-soft); }
      .form-hint { font-size:.85rem; color: var(--muted); }
      .timeline-card { background: linear-gradient(180deg, var(--slate-800), var(--slate-900)); border-radius: 1rem; color:#e2e8f0; box-shadow: inset 0 0 12px rgba(255,255,255,.05); }
      .timeline { height: 100px; border-radius: 1rem; background: var(--slate-900); cursor: grab; position: relative; overflow-x: auto; overflow-y: hidden; white-space: nowrap; }
      .timeline:active { cursor: grabbing; }
      .segments { height: 100%; position: relative; }
      .segment { display:inline-block; position:absolute; height:48px; bottom:12px; border-radius:4px; background: linear-gradient(90deg,#38bdf8,#3b82f6); opacity:.9; border-right:2px solid var(--slate-900); will-change: transform; }
      .segment:hover { opacity:1; transform: translateZ(0) scaleY(1.05); transition:.2s; }
      .segment::after { content: attr(title); position:absolute; bottom:100%; left:50%; transform: translateX(-50%); font-size:10px; background: var(--slate-800); color:#fff; padding:2px 6px; border-radius:4px; opacity:0; pointer-events:none; white-space:nowrap; transition:.2s; }
      .segment:hover::after { opacity:1; bottom:110%; }
      .time-ruler { position:absolute; top:8px; left:0; height:24px; color:#94a3b8; font-size:12px; z-index:3; pointer-events:none; }
      .time-ruler > div { position:absolute; transform: translateX(-50%); }
      .playhead { position:absolute; top:0; height:100%; width:2px; background: var(--danger); box-shadow:0 0 8px rgba(239,68,68,.8); z-index:4; pointer-events:none; }
      .center-cursor { position:absolute; top:0; bottom:0; width:2px; background: rgba(255,255,255,.3); left:50%; transform: translateX(-50%); pointer-events:none; z-index:5; }
      
      /* Dark mode */
      body.dark { --bg1: #1e293b; --bg2: #0f172a; --ink: #e2e8f0; --muted: #94a3b8; }
      body.dark .card { background: #2c3e50; color: #e2e8f0; border-color: #34495e; }
      body.dark .form-control, body.dark .form-select { background-color: #34495e; color: #e2e8f0; border-color: #4a627a; }
      body.dark .form-control::placeholder { color: #94a3b8; }
      body.dark .form-control:focus, body.dark .form-select:focus { background-color: #34495e; color: #e2e8f0; border-color: var(--brand-500); box-shadow: 0 0 0 .25rem rgba(37, 99, 235, .25); }
      body.dark .timeline-card { background: linear-gradient(180deg, #1a2330, #0f172a); }
      body.dark .timeline { background: #0f172a; }
      body.dark .segment:hover::after { background: #1e293b; }
      body.dark .text-muted { color: var(--muted) !important; }
      
      @media (max-width: 768px) {
        .controls { flex-wrap: wrap; }
        .timeline { height: 84px; }
        .segment { height: 36px; }
      }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
  </head>
  <body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
      <div class="container-fluid">
        <a class="navbar-brand fw-bold" href="/">üìπ NVR</a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
          <ul class="navbar-nav me-auto">
            <li class="nav-item"><a class="nav-link" href="/index.html">Dashboard</a></li>
            <li class="nav-item"><a class="nav-link" href="/manage-cameras.html">Camera Manager</a></li>
            <li class="nav-item"><a class="nav-link active" aria-current="page" href="/playback.html">Playback</a></li>
          </ul>
          <ul class="navbar-nav">
            <li class="nav-item">
              <button id="dark-toggle" class="btn btn-outline-light">
                <i class="bi bi-moon-fill"></i>
              </button>
            </li>
          </ul>
        </div>
      </div>
    </nav>

    <div class="container py-4">
      <div class="card p-3 mb-3">
        <div class="row g-3 align-items-end">
          <div class="col-12 col-md-3">
            <label class="form-label">üé• Pilih Kamera</label>
            <select id="cameraSelect" class="form-select" aria-label="Pilih kamera"></select>
          </div>
          <div class="col-12 col-md-6">
            <div class="row g-2">
              <div class="col-6">
                <label class="form-label">Waktu Mulai</label>
                <input type="datetime-local" id="startTime" class="form-control">
              </div>
              <div class="col-6">
                <label class="form-label">Waktu Selesai</label>
                <input type="datetime-local" id="endTime" class="form-control">
              </div>
            </div>
          </div>
          <div class="col-12 col-md-3 d-flex justify-content-end">
             <button id="filterBtn" class="btn btn-primary">Tampilkan</button>
          </div>
        </div>
      </div>

      <div class="card p-3 mb-3">
        <div class="row g-3">
          <div class="col-12 col-lg-8">
            <div class="ratio ratio-16x9">
              <video id="player" controls playsinline></video>
            </div>
            <div class="mt-3 small text-muted d-flex justify-content-between">
              <div id="currentLabel">‚Äî</div>
              <div id="segmentLabel">‚Äî</div>
            </div>
             <div class="controls d-flex align-items-center flex-wrap mt-3">
              <button id="prevBtn" class="btn btn-sm btn-outline-primary" aria-label="Sebelumnya">‚èÆ Prev</button>
              <button id="playPauseBtn" class="btn btn-sm btn-primary" aria-label="Putar/Jeda">‚ñ∂ Play</button>
              <button id="nextBtn" class="btn btn-sm btn-outline-primary" aria-label="Berikutnya">Next ‚è≠</button>
              <div class="d-flex align-items-center ms-2">
                <span class="form-hint me-2">Speed</span>
                <select id="speedSelect" class="form-select form-select-sm" style="width:90px" aria-label="Playback speed">
                  <option value="0.5">0.5x</option>
                  <option value="1" selected>1x</option>
                  <option value="2">2x</option>
                  <option value="4">4x</option>
                </select>
              </div>
              <div class="d-flex align-items-center ms-2" style="min-width:200px">
                <span class="form-hint me-2">Zoom</span>
                <input id="zoomRange" type="range" min="1" max="200" value="20" class="form-range" aria-label="Timeline zoom">
              </div>
              <span id="loadingIndicator" class="ms-2" hidden><span class="loader"></span></span>
            </div>
          </div>
          <div class="col-12 col-lg-4">
            <div class="card p-3 timeline-card">
              <h6 class="mb-2">üìÖ Playback Timeline</h6>
              <div class="timeline-container mt-2 position-relative">
                <div class="timeline" id="timeline">
                  <div class="time-ruler" id="ruler"></div>
                  <div class="segments" id="segments"></div>
                  <div class="playhead" id="playhead"></div>
                </div>
                <div class="center-cursor"></div>
              </div>
              <div class="mt-3 small" style="color:#94a3b8;">üí° Tips: Ctrl+Scroll untuk zoom, Scroll untuk geser, klik segmen untuk lompat.</div>
            </div>
          </div>
        </div>
      </div>
      <div class="text-center text-muted small">Server playback membaca data dari database. Jika kosong, pastikan recorder berjalan dan sudah ada rekaman.</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script>
      // ===== Cached elements =====
      const els = {
        player: document.getElementById('player'),
        segmentsWrap: document.getElementById('segments'),
        timeline: document.getElementById('timeline'),
        ruler: document.getElementById('ruler'),
        cameraSelect: document.getElementById('cameraSelect'),
        loading: document.getElementById('loadingIndicator'),
        playhead: document.getElementById('playhead'),
        playPause: document.getElementById('playPauseBtn'),
        prev: document.getElementById('prevBtn'),
        next: document.getElementById('nextBtn'),
        speed: document.getElementById('speedSelect'),
        zoom: document.getElementById('zoomRange'),
        currentLabel: document.getElementById('currentLabel'),
        segmentLabel: document.getElementById('segmentLabel'),
        startTime: document.getElementById('startTime'),
        endTime: document.getElementById('endTime'),
        filterBtn: document.getElementById('filterBtn'),
        darkToggle: document.getElementById('dark-toggle'),
        body: document.body
      };

      // ===== State =====
      let cameras = [];
      let segments = [];
      let cameraFolder = null;
      let pixelsPerSecond = 20;
      let globalStartTime = 0;
      let lastRulerStep = null;
      let rafUpdateCursor = null;
      let rafUpdatePlayhead = null;

      // ===== Helpers =====
      const setLoading = (on) => { els.loading.hidden = !on; };
      const getFileName = (url) => { try { return new URL(url).pathname.split('/').pop(); } catch { return ''; } };
      const toLocalISOString = (date) => {
          const tzoffset = (new Date()).getTimezoneOffset() * 60000; //offset in milliseconds
          const localISOTime = (new Date(date - tzoffset)).toISOString().slice(0, -1);
          return localISOTime.substring(0, 16);
      };

      // --- Dark Mode Logic ---
      const setCookie = (name, value, days) => {
        let expires = "";
        if (days) {
          const date = new Date();
          date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
          expires = "; expires=" + date.toUTCString();
        }
        document.cookie = name + "=" + (value || "") + expires + "; path=/";
      }
      const getCookie = (name) => {
        const nameEQ = name + "=";
        const ca = document.cookie.split(';');
        for (let i = 0; i < ca.length; i++) {
          let c = ca[i];
          while (c.charAt(0) === ' ') c = c.substring(1, c.length);
          if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
        }
        return null;
      }

      const applyTheme = () => {
        const theme = getCookie('theme');
        const icon = els.darkToggle.querySelector('i');
        if (theme === 'dark') {
          els.body.classList.add('dark');
          icon.classList.remove('bi-moon-fill');
          icon.classList.add('bi-sun-fill');
        } else {
          els.body.classList.remove('dark');
          icon.classList.remove('bi-sun-fill');
          icon.classList.add('bi-moon-fill');
        }
      }

      els.darkToggle.addEventListener('click', () => {
        els.body.classList.toggle('dark');
        const isDark = els.body.classList.contains('dark');
        setCookie('theme', isDark ? 'dark' : 'light', 365);
        applyTheme();
      });
      
      // --- End Dark Mode Logic ---

      async function loadCameras() {
        try {
          const res = await fetch('/api/cameras');
          cameras = await res.json();
          els.cameraSelect.innerHTML = cameras.map(c => `<option value="${c.id}">${c.name || c.id}</option>`).join('');
          if (els.cameraSelect.options.length) {
            els.cameraSelect.selectedIndex = 0;
            await onFilter(false); // Muat data dengan filter default, jangan autoplay
          }
        } catch (e) {
          console.error('Failed to load cameras', e);
        }
      }

      async function loadSegments(folder, start, end, autoplay = false) {
        setLoading(true);
        segments = [];
        cameraFolder = 'cam_' + folder;
        
        let url = `/api/playback/${cameraFolder}`;
        const params = new URLSearchParams();
        if (start) params.append('start', start);
        if (end) params.append('end', end);
        if (start || end) url += `?${params.toString()}`;

        try {
          const res = await fetch(url);
          if (!res.ok) throw new Error(`Server responded with ${res.status}`);
          const list = await res.json();
          
          segments = list.map(item => ({ 
            file: item.file, 
            timestamp: item.timestamp, 
            duration: item.duration || 0 
          })).filter(s => s.duration > 0);

          renderTimeline(true);

          if (segments.length > 0) {
            jumpToSegmentIndex(0, 0, autoplay); // Langsung ke segmen pertama
            setTimeout(() => {
              els.timeline.scrollLeft = 0; // Scroll timeline ke awal
              updateCursorLabel();
            }, 50);
          } else {
            els.segmentsWrap.innerHTML = '<div class="p-3 text-white-50">Tidak ada rekaman untuk rentang waktu ini.</div>';
            els.ruler.innerHTML = '';
            els.playhead.style.left = '-999px';
            els.player.src = '';
          }
        } catch (e) {
          console.error('loadSegments error', e);
          els.segmentsWrap.innerHTML = '<div class="text-white p-3">Gagal memuat segmen rekaman.</div>';
        } finally {
          setLoading(false);
        }
      }

      function renderTimeline(forceRuler = false) {
        els.segmentsWrap.innerHTML = '';
        if (!segments.length) return;

        globalStartTime = segments[0].timestamp;
        const lastSeg = segments[segments.length - 1];
        const totalDurationMs = (lastSeg.timestamp + (lastSeg.duration * 1000)) - globalStartTime;
        const totalWidth = (totalDurationMs / 1000) * pixelsPerSecond;
        els.segmentsWrap.style.width = totalWidth + 'px';

        renderRuler(globalStartTime, totalDurationMs, forceRuler);

        const frag = document.createDocumentFragment();
        segments.forEach((s, i) => {
          const leftOffsetMs = s.timestamp - globalStartTime;
          const leftPx = (leftOffsetMs / 1000) * pixelsPerSecond;
          const segmentWidthPx = s.duration * pixelsPerSecond;

          const div = document.createElement('div');
          div.className = 'segment';
          div.style.left = leftPx + 'px';
          div.style.width = segmentWidthPx + 'px';
          div.title = new Date(s.timestamp).toLocaleString();
          div.dataset.index = i;
          frag.appendChild(div);
        });
        els.segmentsWrap.appendChild(frag);
        updateCursorLabel();
      }

      function renderRuler(startMs, totalMs, force = false) {
        const totalSec = totalMs / 1000;
        let stepSec = 3600;
        if (pixelsPerSecond * stepSec < 100) stepSec = 7200;
        if (pixelsPerSecond * 60 > 80) stepSec = 60;
        if (pixelsPerSecond * 10 > 80) stepSec = 10;

        if (!force && stepSec === lastRulerStep) return;
        lastRulerStep = stepSec;

        els.ruler.innerHTML = '';
        const startSec = Math.floor(startMs / 1000);
        const frag = document.createDocumentFragment();
        for (let s = 0; s <= totalSec; s += stepSec) {
          const t = startSec + s;
          const x = s * pixelsPerSecond;
          const el = document.createElement('div');
          el.style.left = x + 'px';
          el.textContent = new Date(t * 1000).toLocaleTimeString([], { hour: '2-digit', minute:'2-digit' });
          frag.appendChild(el);
        }
        els.ruler.appendChild(frag);
      }

      function jumpToSegmentIndex(i, offsetSec = 0, autoplay = true) {
        if (!segments[i]) return;
        const fileUrl = `${segments[i].file}`;
        loadAndPlaySegment(fileUrl, offsetSec, autoplay);
      }

      function loadAndPlaySegment(file, offsetSec = 0, autoplay = true) {
        const { player, playPause, speed } = els;
        player.src = file;

        const onCanPlay = () => {
          if (offsetSec > 0) player.currentTime = offsetSec;
          player.playbackRate = Number(speed.value) || 1;
          if (autoplay) {
            const p = player.play();
            if (p && p.catch) p.catch(() => { playPause.textContent = '‚ñ∂ Play'; });
          }
          player.removeEventListener('canplay', onCanPlay);
        };
        player.addEventListener('canplay', onCanPlay);
        player.load();
      }

      function updateCursorLabel() {
        if (rafUpdateCursor) return;
        rafUpdateCursor = requestAnimationFrame(() => {
          if (!segments.length) { rafUpdateCursor = null; return; }
          const centerPx = els.timeline.scrollLeft + els.timeline.clientWidth / 2;
          const t = new Date(globalStartTime + (centerPx / pixelsPerSecond) * 1000);
          els.currentLabel.textContent = t.toLocaleString();
          rafUpdateCursor = null;
        });
      }

      function updatePlayhead() {
        if (rafUpdatePlayhead) return;
        rafUpdatePlayhead = requestAnimationFrame(() => {
          if (!segments.length || els.player.seeking) { rafUpdatePlayhead = null; return; }
          const currentFile = getFileName(els.player.currentSrc);
          const seg = segments.find(s => s.file.endsWith(currentFile));
          if (!seg) { rafUpdatePlayhead = null; return; }
          const timeFromGlobalStartMs = (seg.timestamp - globalStartTime) + (els.player.currentTime * 1000);
          const x = (timeFromGlobalStartMs / 1000) * pixelsPerSecond;
          els.playhead.style.left = x + 'px';
          if (!els.player.paused) {
            const center = els.timeline.clientWidth / 2;
            els.timeline.scrollLeft = x - center;
          }
          rafUpdatePlayhead = null;
        });
      }

      // ===== Events =====
      els.playPause.addEventListener('click', () => { els.player.paused ? els.player.play() : els.player.pause(); });
      els.player.addEventListener('play', () => els.playPause.textContent = '‚è∏ Pause');
      els.player.addEventListener('pause', () => els.playPause.textContent = '‚ñ∂ Play');
      els.player.addEventListener('ended', () => {
        const name = getFileName(els.player.currentSrc); if (!name) return;
        const idx = segments.findIndex(s => s.file.endsWith(name));
        if (idx > -1 && idx < segments.length - 1) {
          jumpToSegmentIndex(idx + 1, 0);
        }
      });
      els.prev.addEventListener('click', () => {
        const name = getFileName(els.player.currentSrc); if (!name) return;
        const idx = segments.findIndex(s => s.file.endsWith(name));
        if (idx > 0) jumpToSegmentIndex(idx - 1, 0);
      });
      els.next.addEventListener('click', () => {
        const name = getFileName(els.player.currentSrc); if (!name) return;
        const idx = segments.findIndex(s => s.file.endsWith(name));
        if (idx > -1 && idx < segments.length - 1) jumpToSegmentIndex(idx + 1, 0);
      });
      els.speed.addEventListener('change', (e) => { els.player.playbackRate = Number(e.target.value) || 1; });
      
      els.filterBtn.addEventListener('click', () => onFilter(true));
      els.cameraSelect.addEventListener('change', () => onFilter(false));

      async function onFilter(autoplay) {
        const camId = els.cameraSelect.value;
        const start = els.startTime.value ? new Date(els.startTime.value).toISOString() : '';
        const end = els.endTime.value ? new Date(els.endTime.value).toISOString() : '';
        await loadSegments(camId, start, end, autoplay);
      }

      let drag = false, dragStartX = 0;
      els.timeline.addEventListener('mousedown', (e) => { drag = true; dragStartX = e.pageX; els.timeline.style.cursor = 'grabbing'; });
      window.addEventListener('mousemove', (e) => { if (drag) { els.timeline.scrollLeft -= (e.pageX - dragStartX); dragStartX = e.pageX; updateCursorLabel(); } });
      window.addEventListener('mouseup', () => { drag = false; els.timeline.style.cursor = 'grab'; });
      els.timeline.addEventListener('scroll', updateCursorLabel, { passive: true });
      els.timeline.addEventListener('click', (e) => {
        const segEl = e.target.closest('.segment');
        if (segEl) {
          const index = Number(segEl.dataset.index);
          jumpToSegmentIndex(index, 0);
          return;
        }
        const rect = els.timeline.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const targetPx = els.timeline.scrollLeft + clickX;
        const targetTimeMs = globalStartTime + (targetPx / pixelsPerSecond) * 1000;
        const s = segments.find(s => targetTimeMs >= s.timestamp && targetTimeMs <= s.timestamp + (s.duration * 1000));
        if (s) {
          const offsetSec = (targetTimeMs - s.timestamp) / 1000;
          const idx = segments.indexOf(s);
          jumpToSegmentIndex(idx, offsetSec);
        }
      });
      els.timeline.addEventListener('wheel', (e) => {
        e.preventDefault();
        if (e.ctrlKey) {
          const min = Number(els.zoom.min), max = Number(els.zoom.max);
          const old = pixelsPerSecond;
          const rect = els.timeline.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const timeAtCursor = (els.timeline.scrollLeft + mouseX) / old;
          const factor = 1.1;
          pixelsPerSecond = e.deltaY < 0 ? (pixelsPerSecond * factor) : (pixelsPerSecond / factor);
          pixelsPerSecond = Math.max(min, Math.min(max, pixelsPerSecond));
          els.zoom.value = pixelsPerSecond;
          renderTimeline();
          els.timeline.scrollLeft = (timeAtCursor * pixelsPerSecond) - mouseX;
          updateCursorLabel();
        } else {
          els.timeline.scrollLeft += (e.deltaX + e.deltaY);
        }
      }, { passive: false });
      els.zoom.addEventListener('input', (e) => { pixelsPerSecond = Number(e.target.value); renderTimeline(); });
      els.player.addEventListener('timeupdate', updatePlayhead);
      
      // Init
      function initialize() {
        applyTheme();
        const now = new Date();
        const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);
        els.startTime.value = toLocalISOString(yesterday);
        els.endTime.value = toLocalISOString(now);
        loadCameras();
      }

      initialize();
    </script>
  </body>
</html>
